import { Octokit } from "@octokit/rest"
import { Violation } from "@wispbit/sdk/types"

import { ModeOptions } from "./types"

export interface PullRequestComment {
  body: string
  path: string
  line: number
  side: "LEFT" | "RIGHT"
  startLine?: number
  startSide?: "LEFT" | "RIGHT"
}

export async function formatAsGithubPullRequestReview(
  results: { fileName: string; violations: Violation[] }[],
  ciOptions: ModeOptions
) {
  const allComments: PullRequestComment[] = []
  let totalViolations = 0

  for (const file of results ?? []) {
    if (file.violations && file.violations.length > 0) {
      totalViolations += file.violations.length
      for (const violation of file.violations) {
        // skip cached violations from making comments again
        if (violation.isCached) continue
        allComments.push({
          body: `[${violation.rule.name}](https://github.com/${ciOptions.githubRepository?.split("/")[0]}/${ciOptions.githubRepository?.split("/")[1]}/blob/${ciOptions.githubSha ?? ""}/${violation.rule.directory ? violation.rule.directory + "/" : ""}.wispbit/rules/${violation.rule.name}.md) ${violation.description}`,
          path: file.fileName,
          line: violation.line.end,
          side: violation.line.side === "right" ? "RIGHT" : "LEFT",
          startLine: violation.line.start !== violation.line.end ? violation.line.start : undefined,
          startSide:
            violation.line.start !== violation.line.end
              ? violation.line.side === "right"
                ? "RIGHT"
                : "LEFT"
              : undefined,
        })
      }
    }
  }

  if (allComments.length > 0) {
    const octokit = new Octokit({ auth: ciOptions.githubToken })
    const [owner, repo] = ciOptions.githubRepository?.split("/") ?? []
    await octokit.request("POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews", {
      owner,
      repo,
      pull_number: Number(ciOptions.githubPullRequestNumber),
      body: `Found ${totalViolations} violation${totalViolations === 1 ? "" : "s"} using [wispbit](https://github.com/wispbit-ai/wispbit)`,
      event: "COMMENT",
      commit_id: ciOptions.githubSha ?? "",
      comments: allComments,
    })
  }
}

/**
 * Format code review results as markdown
 */
export function formatAsMarkdown(results: { fileName: string; violations: Violation[] }[]): string {
  const totalViolations = results.reduce((sum, file) => sum + (file.violations?.length || 0), 0)

  if (totalViolations === 0) {
    return `# üéâ Code Review Complete

No violations found! All files passed the review.`
  }

  let markdown = `# üìã Code Review Results

Found **${totalViolations}** violation${totalViolations === 1 ? "" : "s"} across **${results.filter((f) => f.violations && f.violations.length > 0).length}** file${results.filter((f) => f.violations && f.violations.length > 0).length === 1 ? "" : "s"}.

`

  for (const file of results) {
    if (file.violations && file.violations.length > 0) {
      markdown += `## üìÅ \`${file.fileName}\`

`
      for (const violation of file.violations) {
        const lineInfo =
          violation.line.start === violation.line.end
            ? `Line ${violation.line.start}`
            : `Lines ${violation.line.start}-${violation.line.end}`

        markdown += `### ‚ö†Ô∏è ${violation.rule?.name || "Rule Violation"}

**${lineInfo}**

${violation.description}

`
        if (violation.rule?.directory) {
          markdown += `_Rule: [\`${violation.rule.name}\`](.wispbit/rules/${violation.rule.name}.md)_

`
        }
      }
    }
  }

  markdown += `---

*Generated by [wispbit](https://github.com/wispbit-ai/wispbit)*`

  return markdown
}

/**
 * Format code review results as plaintext
 */
export function formatAsPlaintext(
  results: { fileName: string; violations: Violation[] }[]
): string {
  const totalViolations = results.reduce((sum, file) => sum + (file.violations?.length || 0), 0)
  const filesWithViolations = results.filter((f) => f.violations && f.violations.length > 0)

  if (totalViolations === 0) {
    return `üéâ Code Review Complete

No violations found! All files passed the review.`
  }

  let output = `üìã Code Review Results

Found ${totalViolations} violation${totalViolations === 1 ? "" : "s"} across ${filesWithViolations.length} file${filesWithViolations.length === 1 ? "" : "s"}.

`

  for (const file of results) {
    if (file.violations && file.violations.length > 0) {
      output += `üìÅ ${file.fileName}
${"=".repeat(file.fileName.length + 2)}

`
      for (const violation of file.violations) {
        const lineInfo =
          violation.line.start === violation.line.end
            ? `line ${violation.line.start}`
            : `lines ${violation.line.start}-${violation.line.end}`

        output += `‚ö†Ô∏è  ${violation.rule?.name || "Rule Violation"} (${lineInfo})
   ${violation.description}

`
      }
    }
  }

  output += `Generated by wispbit (https://github.com/wispbit-ai/wispbit)`

  return output
}
